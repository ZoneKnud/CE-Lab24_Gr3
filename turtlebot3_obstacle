#!/usr/bin/env python
#################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#################################################################################

# Authors: Gilbert #

# import rospy
# import math
# from sensor_msgs.msg import LaserScan
# from geometry_msgs.msg import Twist

import rospy
import math
import time
from random import randrange
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import sys
import select
import tty
import termios
import math
import requests
import json


from readFromLightSensor import lightSensorRead
# from readFromSonar import sonarSensorRead
from leds import gpioLED


import time
import RPi.GPIO as GPIO


LINEAR_VEL = 0.15
ANGULAR_VEL = 1.5
STOP_DISTANCE = 0.4
LIDAR_ERROR = 0.05
SAFE_STOP_DISTANCE = STOP_DISTANCE + LIDAR_ERROR


CLOSE_DISTANCE = 0.3
MIDDLE_DISTANCE = CLOSE_DISTANCE + 0.2
FAR_DISTANCE = MIDDLE_DISTANCE + 0.2


# def calculate_speed(min_distance, min_distance_angle):

def Average(lst): 
	bogus_readings = lst.count(5)
	length = len(lst) - bogus_readings
	average = 0
	for i in lst:
		if i != 5:
			average += i

	if length > 0:
		average = average / length
		return average
	else:
		return 0
	


class Obstacle():
	def __init__(self):
		self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
		self.obstacle()

	def is_key_available(self):
		return select.select([sys.stdin],[],[],0) == ([sys.stdin],[],[])
			
	def get_key(self):
		return sys.stdin.read(1)
		
	def get_scan(self):
		# print("get scan called")
		scan = rospy.wait_for_message('scan', LaserScan)
		# print("got scan")
		scan_filter = []
	   
		samples = len(scan.ranges)  # The number of samples is defined in 
									# turtlebot3_<model>.gazebo.xacro file,
									# the default is 360.
  
		scan_filter = scan.ranges

		# print(type(scan_filter))
		scan_filter = list(scan_filter)
		# print(scan_filter)

		# for i in range(samples_view):
		for i in range(samples):
			if scan_filter[i] == float('Inf'):
				scan_filter[i] = 5
			elif scan_filter[i] < 0.001:
				# print("Close to zero!")
				scan_filter[i] = 5
			elif math.isnan(scan_filter[i]):
				print("Yo not a number bro!")
				scan_filter[i] = 5

		time.sleep(0.01)
		
		return scan_filter

	def obstacle(self):
		# print("hello world")
		twist = Twist()
		
		twist.linear.x = 0.1
		twist.angular.z = 0.0
		self._cmd_pub.publish(twist)		

		lightSensor = lightSensorRead()
		# sonarSensor = sonarSensorRead()

		ledRed = gpioLED(26)
		ledGreen = gpioLED(16)

		# time.sleep(2)

		# print("Robot init done")

		# time.sleep(3)

		

		while not rospy.is_shutdown():
			if self.is_key_available():
				char = self.get_key()
				if char.lower() == 'q':
					twist.linear.x = 0.0
					twist.angular.z = 0.0
					self._cmd_pub.publish(twist)
					return


			lidar_distances = self.get_scan()


			cnt_intervals = 24
			angle_range = len(lidar_distances)

			cones = []

			for i in range(0, cnt_intervals):
				index1 = int((angle_range / cnt_intervals) * i)
				index2 = int((angle_range / cnt_intervals) * (i + 1))
				# rospy.loginfo(lidar_distances[index1:index2])

				average = Average(lidar_distances[index1:index2])
				cones.append(average)
				# time.sleep(5)

			# for i, cone in enumerate(cones):
			# 	rospy.loginfo(str(i) + ": " + str(cone))
   			
			lightSensor.getAndUpdateColour()
			rospy.loginfo(lightSensor.currentColor)


			# speed er linear

			# angular er den inverse

			averages = []
			# find gennemsnittet af de foreste.
   
			averages.append(Average(cones[20:22]))
			averages.append((cones[0] + cones[23]) / 2)
			averages.append(Average(cones[:3]))

			binaries = []

			####################################

			if averages[0] < CLOSE_DISTANCE:
				# Vi vil gerne have at den drejer lidt mod venstre
				binaries.append(True)
			else:
				binaries.append(False)
			
			if averages[1] < CLOSE_DISTANCE:
				binaries.append(True)
			else:
				binaries.append(False)
			
			if averages[2] < CLOSE_DISTANCE:
				binaries.append(True)
			else:
				binaries.append(False)

			#####################################

			if min(cones[20:22]) < MIDDLE_DISTANCE:
				# Vi vil gerne have at den drejer lidt mod venstre
				binaries.append(True)
			else:
				binaries.append(False)
			
			if min([cones[0], cones[23]]) < MIDDLE_DISTANCE:
				binaries.append(True)
			else:
				binaries.append(False)
			
			if min(cones[:3]) < MIDDLE_DISTANCE:
				binaries.append(True)
			else:
				binaries.append(False)


			####### Send data to server ###########
			data_to_send = [cones, binaries, lightSensor.currentColor]

			r = requests.post('http://192.168.137.1:5000/receive_data', json={"data": json.dumps(data_to_send)})



			####### Movement logic ###########

			if binaries[0] and binaries[1] and binaries[2]:
				# Turn hard
				twist.linear.x = 0
				twist.angular.z = ANGULAR_VEL
				self._cmd_pub.publish(twist)
				time.sleep(1)

			elif binaries[0] and binaries[1]:
				# Turn to the left sharp
				twist.linear.x = -LINEAR_VEL / 6
				twist.angular.z = ANGULAR_VEL
				self._cmd_pub.publish(twist)
				time.sleep(0.5)

			elif binaries[1] and binaries[2]:
				# Turn to the right sharp
				twist.linear.x = -LINEAR_VEL / 6
				twist.angular.z = -ANGULAR_VEL
				self._cmd_pub.publish(twist)
				time.sleep(0.5)
				
			
			elif binaries[0]:
				index = cones.index(min(cones[20:23])) # Giver 0, 1 eller 2.
				index -= 20
				# Calculate the angular and linear speed:
				linear_speed = LINEAR_VEL - ((LINEAR_VEL / 9) * (3- index))
				# If linear speed is high, then angular speed needs to be low.
				angular_speed = ANGULAR_VEL - ((ANGULAR_VEL / 6) * (3- index))

				twist.linear.x = linear_speed
				twist.angular.z = angular_speed
				print(index)

			elif binaries[1]:
				sign = 1
				if cones[0] < cones[23]:
					sign = -1

				# Calculate the angular and linear speed:
				linear_speed = LINEAR_VEL / 9
				# If linear speed is high, then angular speed needs to be low.
				angular_speed = sign * (ANGULAR_VEL)

				twist.linear.x = linear_speed
				twist.angular.z = angular_speed

			elif binaries[2]:
				reverse = cones[:3]
				reverse.reverse()
				# print(cones[:3])
				# print(reverse)
				# print(min(reverse))
				index = reverse.index(min(reverse)) # Giver 0, 1 eller 2
				# Calculate the angular and linear speed:
				linear_speed = LINEAR_VEL - ((LINEAR_VEL / 9) * (3- index))
				# If linear speed is high, then angular speed needs to be low.
				angular_speed = -ANGULAR_VEL - ((ANGULAR_VEL / 6) * (3- index))

				twist.linear.x = linear_speed
				twist.angular.z = angular_speed
			
			################### MIDDLE_DISTANCE ####################
   

			# 2,1,0
			# 5,4,3
			# if binaries[0] and binaries[1] and binaries[2]:
			# 	# Turn hard
			# 	twist.linear.x = 0
			# 	twist.angular.z = ANGULAR_VEL
			# 	self._cmd_pub.publish(twist)
			# 	time.sleep(1)

			elif binaries[3] and binaries[4]:
				# Turn to the left
				twist.linear.x = LINEAR_VEL
				twist.angular.z = ANGULAR_VEL / 2
				self._cmd_pub.publish(twist)
				time.sleep(0.5)

			elif binaries[4] and binaries[5]:
				# Turn to the right
				twist.linear.x = LINEAR_VEL
				twist.angular.z = -ANGULAR_VEL / 2
				self._cmd_pub.publish(twist)
				time.sleep(0.5)

			else:
				twist.linear.x = LINEAR_VEL
				twist.angular.z = 0

			print("linear: " + str(twist.linear.x))
			print("angular: " + str(twist.angular.z))
					


			self._cmd_pub.publish(twist)
			turtlebot_moving = True


def main():
	rospy.init_node('turtlebot3_obstacle')
	try:
		obstacle = Obstacle()
	except rospy.ROSInterruptException:
		pass

if __name__ == '__main__':
	main()

